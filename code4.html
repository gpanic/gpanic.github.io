<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Gregor Panič - Game Developer</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link href="css/highlight/github.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,200,300,600,700,900' rel='stylesheet' type='text/css'>
  </head>
  <body>

    <section class="code-samples">
      <div class="container">
        <div class="row">
        <div class="header">
          <div class="number">04</div>
          <div class="name">Trigger and action system (Unity C#)</div>
          <div class="back"><a href="/">&laquo; Back</a></div>
        </div>
        <div class="description">
          <h3>Description</h3>
          <p>
            A system of different triggers that can trigger different actions. The abstract class TargetAction allows for decoupling of actions from their triggers.
          </p>
          <a href="https://github.com/gpanic/code-samples/tree/master/CodeSample4/TriggersAndActions" class="button">GitHub</a>
        </div>
      </div>

<div class="row">
<div class="code-sample">
<h3>TargetAction.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;

public abstract class TargetAction : MonoBehaviour
{
    public abstract void StartAction();
    public abstract void EndAction();
}</code></pre>
</div>
</div>

<div class="row">
<div class="code-sample">
<h3>SpaceTrigger.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;

// triggers all actions on a specified target when the player enters the trigger space
public class SpaceTrigger : MonoBehaviour
{
    public GameObject target;
    public bool triggerStartAction = true;
    public bool triggerEndAction = true;
    private TargetAction[] targetActions = new TargetAction[0];

    private void Start()
    {
        if (target)
        {
            targetActions = target.GetComponents&lt;TargetAction&gt;();
        }
    }

    private void OnTriggerEnter(Collider col)
    {
        if (col.tag == Tags.player && triggerStartAction)
        {
            foreach (TargetAction ta in targetActions)
            {
                ta.StartAction();
            }
        }
    }

    private void OnTriggerExit(Collider col)
    {
        if (col.tag == Tags.player && triggerEndAction)
        {
            foreach (TargetAction ta in targetActions)
            {
                ta.EndAction();
            }
        }
    }
}</code></pre>
</div>
</div>

<div class="row">
<div class="code-sample">
<h3>TargetTrigger.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;

// triggers all actions on a specified game object when player connects to the target
public class TargetTrigger : HookableObject
{
    public GameObject target;
    public bool triggetStartAction = true;
    public bool triggetEndAction = true;
    private TargetAction[] targetActions = new TargetAction[0];

    void Start()
    {
        if (target)
        {
            targetActions = target.GetComponents&lt;TargetAction&gt;();
        }
    }

    public override void Unhhooked(HookController controller, HookState state)
    {
        if (triggetEndAction)
        {
            foreach (TargetAction ta in targetActions)
            {
                ta.EndAction();
            }
        }
    }

    public override void Hooked(HookController controller, HookState state)
    {
        if (triggetStartAction)
        {
            foreach (TargetAction ta in targetActions)
            {
                ta.StartAction();
            }
        }
    }
}</code></pre>
</div>
</div>

<div class="row">
<div class="code-sample">
<h3>RotateBeamAction.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;

// rotates beam around a pivot point when called to do so
public class RotateBeamAction : TargetAction
{
    private enum State { RotatingForward, RotatingBack, Stationary };

    public Vector3 rotationAxis = new Vector3(1, 0, 0);
    public float rotationAmount = 90;
    public float rotationForwardTime = 4.0f;
    public float rotationBackwardsTime = 4.0f;

    private Transform pivot;
    private float rotationForwardTimer = 0.0f;
    private float rotationBackwardsTimer = 0.0f;
    private Quaternion fromRotation;
    private Quaternion toRotation;
    private Quaternion currentRotation;
    private Vector3 originalPivotPosition;
    private State state = State.Stationary;

    // we want to always rotate in a single direction with the same speed
    // we use rotationPercent to mark rotation progress and to translate
    // between two possibly different rotation times
    private float rotationPercent = 0.0f;

    private void Start()
    {
        pivot = transform.FindChild("pivot").GetComponent&lt;Transform&gt;();
        fromRotation = transform.localRotation;
        toRotation = fromRotation * Quaternion.AngleAxis(rotationAmount,
            transform.InverseTransformDirection(rotationAxis));
        originalPivotPosition = pivot.position;
    }

    private void Update()
    {
        switch (state)
        {
            case State.RotatingForward:
                RotateForwardAroundPivot();
                break;
            case State.RotatingBack:
                RotateBackAroundPivot();
                break;
        }
    }

    private void RotateForwardAroundPivot()
    {
        RotateAroundPivot();
        rotationForwardTimer += Time.deltaTime;
        rotationPercent = rotationForwardTimer / rotationForwardTime;
        if (rotationForwardTimer &gt;= rotationForwardTime)
        {
            rotationForwardTimer = 0.0f;
            state = State.Stationary;
        }
    }

    private void RotateBackAroundPivot()
    {
        RotateAroundPivot();
        rotationBackwardsTimer -= Time.deltaTime;
        rotationPercent = rotationBackwardsTimer / rotationBackwardsTime;
        if (rotationBackwardsTimer &lt;= 0)
        {
            rotationBackwardsTimer = rotationBackwardsTime;
            state = State.Stationary;
        }
    }

    private void RotateAroundPivot()
    {
        transform.localRotation = Quaternion.Lerp(fromRotation, toRotation,
            Mathf.Clamp01(rotationPercent));
        transform.position += originalPivotPosition - pivot.position;
    }

    public override void StartAction()
    {
        state = State.RotatingForward;
        rotationForwardTimer = rotationPercent * rotationForwardTime;
    }

    public override void EndAction()
    {
        state = State.RotatingBack;
        rotationBackwardsTimer = rotationPercent * rotationBackwardsTime;
    }
}</code></pre>
</div>
</div>

<div class="row">
<div class="code-sample">
<h3>MoveAction.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;

public class MoveAction : TargetAction
{
    private enum State { MovingForward, MovingBack, Waiting, Stationary };

    public Transform moveTo;
    public bool moveBack = true;
    public float moveTime = 3.0f;
    public float waitTime = 2.5f;

    private Vector3 originalPosition;
    private float moveTimer = 0.0f;
    private float waitTimer = 0.0f;
    private int connectedHooks;
    private Vector3 currentPosition;
    private Vector3 oldPosition;
    private State state = State.Stationary;

    private void Start()
    {
        GameObject.Find("killplanes").GetComponent&lt;Killplane&gt;().OnTeleport += OnTeleport;
        originalPosition = transform.position;
        currentPosition = originalPosition;
    }

    // interpolate position between fixed updates
    private void Update()
    {
        float t = ((Time.time - Time.fixedTime) / Time.fixedDeltaTime);
        Vector3 pos = Vector3.Lerp(oldPosition, currentPosition, t);
        transform.position = pos;
    }

    private void FixedUpdate()
    {
        oldPosition = currentPosition;
        transform.position = currentPosition;

        switch (state)
        {
            case State.MovingForward:
                moveTimer += Time.deltaTime;
                Move();
                if (moveTimer &gt;= moveTime)
                {
                    state = State.Stationary;
                    moveTimer = moveTime;
                }
                break;
            case State.Waiting:
                waitTimer += Time.deltaTime;
                if (waitTimer &gt;= waitTime)
                {
                    state = State.MovingBack;
                    waitTimer = 0.0f;
                }
                break;
            case State.MovingBack:
                moveTimer -= Time.deltaTime;
                Move();
                if (moveTimer &lt;= 0.0f)
                {
                    state = State.Stationary;
                    moveTimer = 0.0f;
                }
                break;
        }

        // do not actually move the object on FixedUpdate
        // only calculate next position for Update to interpolate
        // the position to
        currentPosition = transform.position;
        transform.position = oldPosition;
    }

    // when the player respawns, reset
    private void OnTeleport()
    {
        currentPosition = originalPosition;
        transform.position = originalPosition;
        state = State.Stationary;
        moveTimer = 0;
        waitTimer = 0;
    }

    private void Move()
    {
        transform.position = Vector3.Lerp(originalPosition, moveTo.position,
            Mathf.Clamp01(moveTimer / moveTime));
    }

    public override void StartAction()
    {
        ++connectedHooks;

        // do not react to a second hook being connected
        if (transform.position == originalPosition && connectedHooks == 1)
        {
            state = State.MovingForward;
        }
    }

    public override void EndAction()
    {
        --connectedHooks;

        // only react when the last hook has been disconnected
        if (moveBack && connectedHooks == 0)
        {
            if (moveTimer &gt;= moveTime)
            {
                state = State.Waiting;
            }
            else
            {
                state = State.MovingBack;
            }
        }
    }
}
</code></pre>
</div>
</div>

        </section>
      </div>
    </div>

    <section class="footer">
      <div class="social">
        <a href="mailto:gregor.panic@gmail.com">
          <img src="images/email_circle.png">
        </a>
        <a href="https://github.com/gpanic">
          <img src="images/github_circle.png">
        </a>
        <a href="https://si.linkedin.com/in/gregorpanic">
          <img src="images/linkedin_circle.png">
        </a>
      </div>
      &copy;2015 Gregor Panič
    </section>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/highlight.pack.js"></script> 
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>