<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Gregor Panič - Game Developer</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link href="css/highlight/github.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,200,300,600,700,900' rel='stylesheet' type='text/css'>
  </head>
  <body>

    <section class="code-samples">
      <div class="container">
        <div class="row">
        <div class="header">
          <div class="number">03</div>
          <div class="name">Object culling (Unity C#)</div>
          <div class="back"><a href="/">&laquo; Back</a></div>
        </div>
        <div class="description">
          <h3>Description</h3>
          <p>
            A culling system that uses distance to activate and deactivate objects. Culling groups contain draw distances and groups
            of objects to activate/deactivate. The abstract class ObjectCuller contains the the genral algorithm while the activate
            and deactivate operations are left to be implemented by concrete classes like ParticleSystemCuller, which enables/disables
            a particle system when it's beyond the specified draw distance. A set number of objects is culled per frame, which means the
            culling operation has a minimal performance impact even with large numbers of objects, but it takes longer for the object
            to activate/deactivate.
          </p>
          <a href="https://github.com/gpanic/code-samples/tree/master/CodeSample4/CullingSystem" class="button">GitHub</a>
        </div>
      </div>

<div class="row">
<div class="code-sample">
<h3>ObjectCuller.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;
using System;

public abstract class ObjectCuller : MonoBehaviour
{
    [Serializable]
    public class CullingGroup
    {
        public string groupName;
        public GameObject[] objectGroups;
        public float cullDistance = 350.0f;
    }

    public float updateObjectsPerFrame = 1;
    public CullingGroup[] cullingGroups;

    private Transform player;
    private int cullingGroupIndex = 0;
    private int objectGroupIndex = 0;
    private int objectIndex = 0;

    protected abstract void Activate(GameObject objectToActivate);
    protected abstract void Deactivate(GameObject objectToDeactivate);

    private void Start()
    {
        if ((player = GameObject.FindGameObjectWithTag(Tags.player).transform) == null)
        {
            Debug.LogError("Missing a player object.");
            enabled = false;
        }
        enabled = ValidateCullingGroups();
    }

    private void Update()
    {
        // we can update as many objects per frame as we want, a tradeoff between
        // activation/deactivation speed and performance
        for (int i = 0; i &lt; updateObjectsPerFrame; ++i)
        {
            CullingGroup cullingGroup = cullingGroups[cullingGroupIndex];
            GameObject objectGroup = cullingGroup.objectGroups[objectGroupIndex];
            Transform obj = objectGroup.transform.GetChild(objectIndex);

            if (IsBeyondDrawDistance(player.position, obj.position, cullingGroup))
            {
                Deactivate(obj.gameObject);
            }
            else
            {
                Activate(obj.gameObject);
            }


            // update and wrap culling group, object group and object indices
            ++objectIndex;
            if (objectIndex &gt;= objectGroup.transform.childCount)
            {
                objectIndex = 0;
                ++objectGroupIndex;
            }

            if (objectGroupIndex &gt;= cullingGroup.objectGroups.Length)
            {
                objectGroupIndex = 0;
                ++cullingGroupIndex;
                cullingGroupIndex %= cullingGroups.Length;
            }
        }
    }

    private bool IsBeyondDrawDistance(Vector3 playerPosition, Vector3 objectPosition,
                                        CullingGroup cullingGroup)
    {
        return Vector3.Distance(playerPosition, objectPosition) &gt; cullingGroup.cullDistance;

    }

    // doesn't allow empty culling groups or object groups to not waste time
    private bool ValidateCullingGroups()
    {
        if (cullingGroups.Length == 0)
        {
            Debug.LogError("Script requires at least one culling group.");
            return false;
        }
        else
        {
            foreach (CullingGroup cullingGroup in cullingGroups)
            {
                if (cullingGroup.objectGroups.Length == 0)
                {
                    Debug.LogError("A culling group contains no object groups.");
                    return false;
                }
                else
                {
                    foreach (GameObject objectGroup in cullingGroup.objectGroups)
                    {
                        if (objectGroup.transform.childCount == 0)
                        {
                            Debug.LogError("An object group contains no child objects.");
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
}</code></pre>
</div>
</div>

<div class="row">
<div class="code-sample">
<h3>ParticleSystemCuller.cs</h3>
<pre><code class="c#">using UnityEngine;
using System.Collections;
using System;

public class ParticleSystemCuller : ObjectCuller
{
    protected override void Activate(GameObject objectToActivate)
    {
        ParticleSystem particleSystem = objectToActivate.GetComponent&lt;ParticleSystem&gt;();
        if (particleSystem != null && particleSystem.isStopped)
        {
            particleSystem.Play();
        }
    }

    protected override void Deactivate(GameObject objectToDeactivate)
    { 
        ParticleSystem particleSystem = objectToDeactivate.GetComponent&lt;ParticleSystem&gt;();
        if (particleSystem != null && particleSystem.isPlaying)
        {
            particleSystem.Stop();
        }
    }
            
}</code></pre>
</div>
</div>

        </section>
      </div>
    </div>

    <section class="footer">
      <div class="social">
        <a href="mailto:gregor.panic@gmail.com">
          <img src="images/email_circle.png">
        </a>
        <a href="https://si.linkedin.com/in/gregorpanic">
          <img src="images/linkedin_circle.png">
        </a>
      </div>
      &copy;2015 Gregor Panič
    </section>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/highlight.pack.js"></script> 
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>